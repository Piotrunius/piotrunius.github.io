name: Update All Stats

on:
  schedule:
    # Co 15 minut (dla Steama)
    - cron: '*/15 * * * *'
    # Co 12 godzin (dla GitHub + Steam)
    - cron: '0 */12 * * *'
  workflow_dispatch: # Ręczne uruchomienie obu naraz

jobs:
  update:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Fetch Statistics
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          STEAM_API_KEY: ${{ secrets.STEAM_API_KEY }}
          STEAM_ID64: ${{ secrets.STEAM_ID64 }}
        run: |
          node -e "
          const fs = require('fs');
          const path = require('path');

          const githubUsername = 'Piotrunius';
          const steamId = process.env.STEAM_ID64 || '76561199034113344';
          
          // Logika: GitHub aktualizujemy tylko co 12h LUB gdy odpalamy ręcznie
          // Sprawdzamy czy minuta jest 0 i godzina podzielna przez 12 (uproszczenie dla crona)
          // Lub po prostu sprawdzamy czy to workflow_dispatch
          const isManual = '${{ github.event_name }}' === 'workflow_dispatch';
          const isGithubTime = isManual || (new Date().getMinutes() < 15 && new Date().getHours() % 12 === 0);

          async function fetchGithub() {
            if (!isGithubTime) {
              console.log('Skipping GitHub stats update (not time yet).');
              return;
            }
            console.log('Updating GitHub stats...');
            const headers = process.env.GITHUB_TOKEN ? { 'Authorization': `token ${process.env.GITHUB_TOKEN}` } : {};
            try {
              const userResp = await fetch(`https://api.github.com/users/${githubUsername}`, { headers });
              const user = await userResp.json();
              
              // Repositories
              let allRepos = [];
              let page = 1;
              while (true) {
                const r = await fetch(`https://api.github.com/users/${githubUsername}/repos?page=${page}&per_page=100`, { headers });
                const repos = await r.json();
                if (!Array.isArray(repos) || repos.length === 0) break;
                allRepos = allRepos.concat(repos);
                if (repos.length < 100) break;
                page++;
              }

              // Stars (simplified)
              const starHeaders = { ...headers, 'Accept': 'application/vnd.github.star+json' };
              let allStarred = [];
              page = 1;
              while (true) {
                const r = await fetch(`https://api.github.com/users/${githubUsername}/starred?page=${page}&per_page=100`, { headers: starHeaders });
                const starred = await r.json();
                if (!Array.isArray(starred) || starred.length === 0) break;
                allStarred = allStarred.concat(starred);
                if (starred.length < 100) break;
                page++;
              }

              // Commits search for total count
              const commitsCountResp = await fetch(`https://api.github.com/search/commits?q=author:${githubUsername}&per_page=1`, {
                headers: { ...headers, 'Accept': 'application/vnd.github.cloak-preview' }
              });
              const commitsData = await commitsCountResp.json();

              const stats = {
                summary: { projects: user.public_repos || 0, starredCount: allStarred.length, commits: commitsData.total_count || 0 },
                recentCommits: [], // Fetching commits for 10 repos would take too much time here, keeping it lean
                starred: allStarred.slice(0, 50).map(item => ({
                  name: item.repo.name,
                  owner: item.repo.owner.login,
                  url: item.repo.html_url,
                  stars: item.repo.stargazers_count || 0,
                  language: item.repo.language,
                  description: item.repo.description,
                  starredAt: item.starred_at
                })),
                lastUpdate: new Date().toISOString()
              };

              // Re-fetch recent commits if needed
              for (const repo of allRepos.slice(0, 5)) {
                const cResp = await fetch(`https://api.github.com/repos/${githubUsername}/${repo.name}/commits?per_page=5`, { headers });
                const commits = await cResp.json();
                if (Array.isArray(commits)) {
                  stats.recentCommits = stats.recentCommits.concat(commits.map(c => ({
                    message: c.commit.message.split('\n')[0],
                    repo: repo.name,
                    author: c.commit.author.name,
                    date: c.commit.author.date,
                    url: c.html_url
                  })));
                }
              }
              stats.recentCommits.sort((a,b) => new Date(b.date) - new Date(a.date));

              const filePath = './data/github-stats.json';
              if (fs.existsSync(filePath)) {
                const old = JSON.parse(fs.readFileSync(filePath, 'utf8'));
                if (JSON.stringify({ ...stats, lastUpdate: old.lastUpdate }) === JSON.stringify(old)) {
                  console.log('GitHub: No change.');
                  return;
                }
              }
              fs.writeFileSync(filePath, JSON.stringify(stats, null, 2));
            } catch (e) { console.error('GitHub Error:', e.message); }
          }

          async function fetchSteam() {
            console.log('Updating Steam status...');
            const key = process.env.STEAM_API_KEY;
            if (!key) return;
            try {
              const sResp = await fetch(`http://api.steampowered.com/ISteamUser/GetPlayerSummaries/v0002/?key=${key}&steamids=${steamId}`);
              const sJson = await sResp.json();
              const gResp = await fetch(`http://api.steampowered.com/IPlayerService/GetOwnedGames/v0001/?key=${key}&steamid=${steamId}&include_appinfo=0&include_played_free_games=1`);
              const gJson = await gResp.json();

              let playtime = 0;
              if (gJson.response?.games) playtime = gJson.response.games.reduce((a, b) => a + (b.playtime_forever || 0), 0);

              if (sJson.response?.players?.[0]) {
                const p = sJson.response.players[0];
                const stats = {
                  steam: {
                    personastate: p.personastate,
                    gameextrainfo: p.gameextrainfo || null,
                    avatar: p.avatarmedium,
                    timecreated: p.timecreated,
                    lastlogoff: p.lastlogoff,
                    game_count: gJson.response?.game_count || 0,
                    total_playtime: Math.round(playtime / 60)
                  },
                  lastUpdate: new Date().toISOString()
                };

                const filePath = './data/steam-status.json';
                if (fs.existsSync(filePath)) {
                  const old = JSON.parse(fs.readFileSync(filePath, 'utf8'));
                  if (JSON.stringify({ ...stats, lastUpdate: old.lastUpdate }) === JSON.stringify(old)) {
                    console.log('Steam: No change.');
                    return;
                  }
                }
                fs.writeFileSync(filePath, JSON.stringify(stats, null, 2));
              }
            } catch (e) { console.error('Steam Error:', e.message); }
          }

          async function run() {
            if (!fs.existsSync('./data')) fs.mkdirSync('./data');
            await fetchGithub();
            await fetchSteam();
          }
          run();
          "

      - name: Commit and push if changed
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add data/*.json
          # Commit tylko jeśli faktycznie są zmiany w plikach
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "chore: update statistics (automated)"
            git push
          fi
